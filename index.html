<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Brain Atlas - Fixed Camera</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; width: 100%; height: 100%; }

        /* LOADING BAR */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000; z-index: 999;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; font-family: monospace;
        }
        #progress-text { margin-top: 15px; font-size: 1.2rem; color: #00ff88; }
        .bar-container { width: 60%; height: 4px; background: #333; border-radius: 2px; }
        #progress-bar { width: 0%; height: 100%; background: #00ff88; transition: width 0.2s; }

        /* UI HEADER */
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 15px; box-sizing: border-box;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            display: flex; justify-content: center; pointer-events: none;
        }
        select {
            width: 100%; max-width: 400px; padding: 12px; font-size: 16px;
            background: #222; color: white; border: 1px solid #444; border-radius: 6px;
            pointer-events: auto;
        }
    </style>
</head>
<body>

<div id="loading-screen">
    <div class="bar-container"><div id="progress-bar"></div></div>
    <div id="progress-text">Connecting...</div>
</div>

<div id="ui-container">
    <select id="region-select">
        <option value="">Whole Brain</option>
    </select>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // 1. FAST MATERIALS
    const MAT_BASE = new THREE.MeshLambertMaterial({ color: 0xdddddd });
    const MAT_ACTIVE = new THREE.MeshLambertMaterial({ color: 0xff0055 });
    const MAT_GHOST = new THREE.MeshLambertMaterial({ color: 0x333333, transparent: true, opacity: 0.1 });

    // 2. REGIONS
    const REGIONS = {
        "Frontal Lobe":      ["frontal", "precentral", "rectus", "orbital", "cingulate"],
        "Parietal Lobe":     ["parietal", "postcentral", "precuneus", "supramarginal", "angular"],
        "Temporal Lobe":     ["temporal", "fusiform", "amygdaloid", "uncus"],
        "Occipital Lobe":    ["occipital", "cuneus", "lingual"],
        "Hippocampus":       ["hippocampus", "dentate", "fornix"],
        "Cerebellum":        ["cerebellar", "vermis"],
        "Brain Stem":        ["medulla", "pons", "midbrain", "colliculus", "peduncle", "olive"],
        "Thalamus":          ["thalamus", "geniculate", "habenular", "pineal"],
        "Basal Ganglia":     ["caudate", "putamen", "pallidus", "accumbens", "substantia", "nigra"],
        "Ventricles":        ["ventricle", "aqueduct"]
    };

    // 3. SCENE & CAMERA
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    // Initial position (will be reset by auto-frame later)
    camera.position.set(0, 0, 20);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
    document.body.appendChild(renderer.domElement);

    // --- CONTROLS FIX IS HERE ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    
    // 1. DISABLE PANNING: This stops the brain from sliding off screen
    controls.enablePan = false; 
    
    // 2. LIMIT ZOOM: Prevents getting lost inside or too far away
    controls.minDistance = 5; 
    controls.maxDistance = 40;

    // 3. AUTO ROTATE: Keep it moving slightly so it feels 3D
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.0;

    // Lights
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 10, 10);
    scene.add(dirLight);

    // 4. MANAGER
    let allParts = [];

    function setupModel(model) {
        model.traverse((child) => {
            if (child.isMesh) {
                if (child.material) child.material.dispose();
                child.material = MAT_BASE;
                child.userData.originalName = (child.name || "").toLowerCase();
                allParts.push(child);
            }
        });
    }

    function highlight(regionName) {
        if (!regionName) {
            for (let i = 0; i < allParts.length; i++) allParts[i].material = MAT_BASE;
            return;
        }
        const keywords = REGIONS[regionName];
        for (let i = 0; i < allParts.length; i++) {
            const part = allParts[i];
            let isMatch = false;
            for (let k = 0; k < keywords.length; k++) {
                if (part.userData.originalName.indexOf(keywords[k]) !== -1) {
                    isMatch = true;
                    break;
                }
            }
            part.material = isMatch ? MAT_ACTIVE : MAT_GHOST;
        }
    }

    // 5. UI
    const select = document.getElementById('region-select');
    for (const key in REGIONS) {
        const opt = document.createElement('option');
        opt.value = key;
        opt.innerText = key;
        select.appendChild(opt);
    }
    select.addEventListener('change', (e) => highlight(e.target.value));

    // 6. LOAD
    const loader = new GLTFLoader();
    const statusText = document.getElementById('progress-text');
    const progressBar = document.getElementById('progress-bar');
    const loadingScreen = document.getElementById('loading-screen');

    const url = './rotten_brain.glb?v=' + Math.random();

    loader.load(url, 
        (gltf) => {
            const brain = gltf.scene;
            
            setupModel(brain);

            // --- CENTERING & FRAMING LOGIC ---
            const box = new THREE.Box3().setFromObject(brain);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            // 1. Move brain exactly to center (0,0,0)
            brain.position.sub(center);
            
            // 2. Normalize Size (Make it 10 units wide/tall)
            const maxDim = Math.max(size.x, size.y, size.z);
            const targetSize = 10;
            const scale = targetSize / maxDim; 
            brain.scale.setScalar(scale);

            // 3. Reset Camera Position to look perfectly at it
            camera.position.set(0, 0, 20); // Z=20 guarantees we see the whole thing
            controls.target.set(0, 0, 0);  // Look at center
            controls.update();

            scene.add(brain);

            loadingScreen.style.opacity = 0;
            setTimeout(() => loadingScreen.style.display = 'none', 500);
        }, 
        (xhr) => {
            if (xhr.lengthComputable) {
                const percent = (xhr.loaded / xhr.total) * 100;
                progressBar.style.width = percent + '%';
                statusText.innerText = `Downloading: ${Math.round(percent)}%`;
            } else {
                statusText.innerText = `Downloading...`;
                progressBar.style.width = '50%';
            }
        },
        (err) => {
            console.error(err);
            statusText.innerText = "Load Failed";
            statusText.style.color = "red";
            alert("Error loading model.");
        }
    );

    // 7. RENDER
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

</script>
</body>
</html>
