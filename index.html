<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neural Connectome - Final</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: monospace; }
        canvas { display: block; width: 100%; height: 100%; touch-action: none; }

        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #020202; z-index: 999;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            transition: opacity 0.5s ease;
        }
        .bar-wrap {
            width: 200px; height: 4px; background: #222; margin-top: 15px; border-radius: 2px;
        }
        #load-bar { width: 0%; height: 100%; background: #0088ff; transition: width 0.1s; }
        #status-text { color: #0088ff; font-size: 1.2rem; letter-spacing: 2px; }

        #ui-container {
            position: absolute; bottom: 40px; left: 0; width: 100%;
            display: flex; justify-content: center; pointer-events: none; z-index: 10;
        }
        select {
            pointer-events: auto; padding: 12px 25px; background: rgba(10,15,20,0.95);
            color: #00d8ff; border: 1px solid #004477; border-radius: 8px; font-size: 16px;
            text-transform: uppercase; font-weight: bold; outline: none;
            box-shadow: 0 0 20px rgba(0, 136, 255, 0.2);
        }
    </style>
</head>
<body>

<div id="loading-screen">
    <div id="status-text">INITIALIZING</div>
    <div class="bar-wrap"><div id="load-bar"></div></div>
</div>

<div id="ui-container">
    <select id="region-select"><option value="">Whole Brain</option></select>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

    // --- CONFIG ---
    const STATIC_COUNT = 100000; // Static Structure dots
    const ACTIVE_COUNT = 4000;   // Active "Firing" Nodes
    const CONNECTIONS = 2;       // Beams per node

    const REGIONS = {
        "Frontal Lobe":      ["frontal", "precentral", "rectus", "orbital", "cingulate"],
        "Parietal Lobe":     ["parietal", "postcentral", "precuneus", "supramarginal", "angular"],
        "Temporal Lobe":     ["temporal", "fusiform", "amygdaloid", "hippocampus", "uncus"],
        "Occipital Lobe":    ["occipital", "cuneus", "lingual"],
        "Cerebellum":        ["cerebellar", "vermis"],
        "Brain Stem":        ["medulla", "pons", "midbrain", "colliculus", "peduncle", "olive"],
        "Thalamus":          ["thalamus", "geniculate", "habenular", "pineal"],
        "Basal Ganglia":     ["caudate", "putamen", "pallidus", "accumbens", "substantia", "nigra"]
    };

    // --- TEXTURE ---
    // Create a soft glow sprite programmatically
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.4, 'rgba(100,200,255,0.5)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
    const NEURON_TEX = new THREE.CanvasTexture(canvas);

    // --- SCENE ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x010101);
    
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 18); // Good view distance
    scene.add(camera);

    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false; 
    controls.minDistance = 3; controls.maxDistance = 50;
    controls.autoRotate = true; controls.autoRotateSpeed = 0.5;

    // --- LIGHTING ---
    scene.add(new THREE.AmbientLight(0x555555, 1.0));
    const headLight = new THREE.DirectionalLight(0xffffff, 1.5);
    headLight.position.set(0,0,1);
    camera.add(headLight); // Light locked to camera
    const rimLight = new THREE.DirectionalLight(0x0044ff, 1.5);
    rimLight.position.set(-10, 0, -5);
    scene.add(rimLight);

    // --- MASTER GROUP ---
    // Everything goes in here so it stays synced
    const mainContainer = new THREE.Group();
    scene.add(mainContainer);

    let activeCloud, linesMesh;
    let activeData = []; // Sim data
    let solidMeshes = [];
    let currentRegion = null;

    // --- MATERIALS ---
    const MAT_SOLID = new THREE.MeshLambertMaterial({ color: 0x202020, emissive: 0x000000 });
    const MAT_SOLID_ACTIVE = new THREE.MeshLambertMaterial({ color: 0x303030, emissive: 0x220044 });
    
    const MAT_STATIC = new THREE.PointsMaterial({
        size: 0.035, color: 0x335577, transparent: true, opacity: 0.5, 
        map: NEURON_TEX, depthWrite: false, blending: THREE.AdditiveBlending
    });

    const MAT_ACTIVE = new THREE.PointsMaterial({
        size: 0.08, vertexColors: true, transparent: true, opacity: 1.0, 
        map: NEURON_TEX, depthWrite: false, blending: THREE.AdditiveBlending
    });

    const MAT_LINES = new THREE.LineBasicMaterial({
        vertexColors: true, transparent: true, opacity: 0.4, 
        blending: THREE.AdditiveBlending, depthWrite: false
    });

    // --- ASYNC BUILDER ---
    async function buildNetwork(brain) {
        const loadBar = document.getElementById('load-bar');
        const status = document.getElementById('status-text');
        
        // 1. PREP SOLID CORE
        // We create a list of meshes and calculate total area
        let meshList = [];
        let totalArea = 0;

        brain.traverse(c => {
            if(c.isMesh) {
                c.material = MAT_SOLID;
                c.userData.originalName = (c.name || "").toLowerCase();
                solidMeshes.push(c);
                
                // Compute geometry for sampling
                if(!c.geometry.boundingSphere) c.geometry.computeBoundingSphere();
                const r = c.geometry.boundingSphere.radius;
                const area = 4 * Math.PI * r * r; // Rough sphere area sufficient for weighting
                totalArea += area;
                meshList.push({ mesh: c, area: area, name: c.userData.originalName });
            }
        });
        
        // Add Solid Brain to Container
        mainContainer.add(brain);
        
        // Sort largest meshes first
        meshList.sort((a,b) => b.area - a.area);

        // 2. PREP BUFFERS
        const sPos = new Float32Array(STATIC_COUNT * 3);
        const aPos = new Float32Array(ACTIVE_COUNT * 3);
        const aCol = new Float32Array(ACTIVE_COUNT * 3);
        
        const lineMax = ACTIVE_COUNT * CONNECTIONS * 2; // *2 for vertices per line
        const lPos = new Float32Array(lineMax * 3);
        const lCol = new Float32Array(lineMax * 3);

        let sIndex = 0, aIndex = 0, lIndex = 0;
        const tempPos = new THREE.Vector3();
        const tempNorm = new THREE.Vector3();
        
        status.innerText = "MAPPING NEURONS";
        
        // 3. GENERATE
        const CHUNK = 40;
        for(let i=0; i<meshList.length; i++) {
            const item = meshList[i];
            const ratio = item.area / totalArea;
            
            let sCount = Math.ceil(ratio * STATIC_COUNT);
            if(sCount < 5) sCount = 5;
            let aCount = Math.ceil(ratio * ACTIVE_COUNT);
            if(aCount < 1) aCount = 1;

            const sampler = new MeshSurfaceSampler(item.mesh).build();

            // Region ID
            let regionID = null;
            for(const [r, k] of Object.entries(REGIONS)) {
                if (k.some(w => item.name.includes(w))) { regionID = r; break; }
            }

            // STATIC DOTS
            for(let k=0; k<sCount && sIndex < STATIC_COUNT; k++) {
                sampler.sample(tempPos, tempNorm);
                tempPos.addScaledVector(tempNorm, 0.002); // Tiny offset
                
                // Apply local matrix to put point in same space as mesh
                // Note: Since we added brain to mainContainer, and we will add points to mainContainer,
                // we just need the mesh's transform relative to the brain root.
                // MeshSurfaceSampler samples in local geometry space.
                // We apply the mesh's matrix to get it into the brain object's space.
                tempPos.applyMatrix4(item.mesh.matrix); 

                sPos[sIndex*3] = tempPos.x;
                sPos[sIndex*3+1] = tempPos.y;
                sPos[sIndex*3+2] = tempPos.z;
                sIndex++;
            }

            // ACTIVE DOTS
            for(let k=0; k<aCount && aIndex < ACTIVE_COUNT; k++) {
                sampler.sample(tempPos, tempNorm);
                tempPos.addScaledVector(tempNorm, 0.005); // Float slightly higher
                tempPos.applyMatrix4(item.mesh.matrix);

                const x = tempPos.x, y = tempPos.y, z = tempPos.z;
                aPos[aIndex*3] = x; aPos[aIndex*3+1] = y; aPos[aIndex*3+2] = z;
                
                // Init Dark
                aCol[aIndex*3] = 0; aCol[aIndex*3+1] = 0; aCol[aIndex*3+2] = 0.2;

                activeData[aIndex] = { 
                    region: regionID, 
                    v: -65 - Math.random()*30, 
                    u: 0, 
                    lines: [] // Store which line vertices belong to this node
                };
                
                // Connect to recent neighbors (Clustering)
                if(aIndex > 5) {
                    for(let c=0; c<CONNECTIONS; c++) {
                        // Find a neighbor
                        const target = aIndex - 1 - Math.floor(Math.random()*5);
                        if(target >= 0) {
                            const idx = lIndex * 6; // 2 verts, 3 floats each
                            
                            // Source
                            lPos[idx] = x; lPos[idx+1] = y; lPos[idx+2] = z;
                            // Target
                            lPos[idx+3] = aPos[target*3]; lPos[idx+4] = aPos[target*3+1]; lPos[idx+5] = aPos[target*3+2];

                            // Save reference to Color Indices
                            // (Source Vert RGB + Target Vert RGB)
                            activeData[aIndex].lines.push(idx); 

                            lIndex++;
                        }
                    }
                }
                aIndex++;
            }

            // Async Break
            if(i % CHUNK === 0) {
                loadBar.style.width = Math.round((i/meshList.length)*100) + "%";
                await new Promise(r => setTimeout(r, 0));
            }
        }

        // 4. CREATE OBJECTS
        const sGeo = new THREE.BufferGeometry();
        sGeo.setAttribute('position', new THREE.BufferAttribute(sPos, 3));
        mainContainer.add(new THREE.Points(sGeo, MAT_STATIC));

        const aGeo = new THREE.BufferGeometry();
        aGeo.setAttribute('position', new THREE.BufferAttribute(aPos, 3));
        aGeo.setAttribute('color', new THREE.BufferAttribute(aCol, 3));
        activeCloud = new THREE.Points(aGeo, MAT_ACTIVE);
        mainContainer.add(activeCloud);

        const lGeo = new THREE.BufferGeometry();
        lGeo.setAttribute('position', new THREE.BufferAttribute(lPos, 3));
        lGeo.setAttribute('color', new THREE.BufferAttribute(lCol, 3));
        linesMesh = new THREE.LineSegments(lGeo, MAT_LINES);
        mainContainer.add(linesMesh);

        // 5. FINALIZE SCALING
        // Get bounds of the WHOLE CONTAINER (Brain + Points + Lines)
        const box = new THREE.Box3().setFromObject(mainContainer);
        const size = new THREE.Vector3(); box.getSize(size);
        const center = new THREE.Vector3(); box.getCenter(center);

        // Center logic: Move the CONTAINER content to 0,0,0
        // Wait, easier to just offset the container position.
        // Actually, for rotation pivot to work, we want the content centered relative to the Group pivot.
        // So we translate geometry. But easier: 
        // Just subtract Center from mainContainer.position.
        
        // First, force scale
        const maxDim = Math.max(size.x, size.y, size.z);
        const scaleFactor = 14.0 / maxDim; // Fit to screen
        mainContainer.scale.setScalar(scaleFactor);
        
        // Now re-center based on the scaled size offset
        // Just moving the group to -center works visually
        mainContainer.position.sub(center.multiplyScalar(scaleFactor));

        document.getElementById('loading-screen').style.display = 'none';
    }

    function updateSimulation() {
        if (!activeCloud) return;
        const pCol = activeCloud.geometry.attributes.color.array;
        const lCol = linesMesh.geometry.attributes.color.array;
        const dt = 0.8;

        for (let i = 0; i < ACTIVE_COUNT; i++) {
            const p = activeData[i];
            if(!p) continue;

            const isTarget = (currentActiveRegion && p.region === currentActiveRegion);
            const isWhole = !currentActiveRegion;

            // Sim Input
            let fireProb = isTarget ? 0.96 : (isWhole ? 0.99 : 0.9999);
            const input = (Math.random() > fireProb) ? 30 : 0;

            p.v += (0.04 * p.v * p.v + 5 * p.v + 140 - p.u + input) * dt;
            p.u += (0.02 * (0.2 * p.v - p.u)) * dt;

            if (p.v >= 30.0) {
                p.v = -65; p.u += 8;
                // SPIKE: Node White
                pCol[i*3] = 1.0; pCol[i*3+1] = 1.0; pCol[i*3+2] = 1.0;
                
                // Beam: Blue Pulse
                if(p.lines) {
                    for(let idx of p.lines) {
                        // Gradient Vertex colors for line
                        lCol[idx] = 1.0; lCol[idx+1] = 1.0; lCol[idx+2] = 1.0; 
                        lCol[idx+3] = 0.0; lCol[idx+4] = 0.8; lCol[idx+5] = 1.0; 
                    }
                }
            } else {
                // DECAY
                let r=0, g=0, b=0.2;
                if(isTarget) { r=0.5; g=0.0; b=0.8; } // Active Region Purple
                else if(isWhole) { r=0.0; g=0.1; b=0.2; } 
                
                pCol[i*3] += (r - pCol[i*3]) * 0.15;
                pCol[i*3+1] += (g - pCol[i*3+1]) * 0.15;
                pCol[i*3+2] += (b - pCol[i*3+2]) * 0.15;

                // Fade lines fast
                if(p.lines) {
                    for(let idx of p.lines) {
                        lCol[idx] *= 0.85; lCol[idx+1] *= 0.85; lCol[idx+2] *= 0.85;
                        lCol[idx+3] *= 0.85; lCol[idx+4] *= 0.85; lCol[idx+5] *= 0.85;
                    }
                }
            }
        }
        activeCloud.geometry.attributes.color.needsUpdate = true;
        linesMesh.geometry.attributes.color.needsUpdate = true;
    }

    // --- LOADER ---
    const loader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
    loader.setDRACOLoader(draco);

    const status = document.getElementById('status-text');
    const loadBar = document.getElementById('load-bar');
    
    status.innerText = "DOWNLOADING DATA...";

    loader.load('./rotten_brain.glb', (gltf) => {
        // Immediately start building, no manual center manipulation on mesh needed
        // we handle that in the builder via Group logic
        buildNetwork(gltf.scene);
    }, (xhr) => {
        if(xhr.lengthComputable) {
            loadBar.style.width = Math.round((xhr.loaded/xhr.total)*100) + "%";
        }
    }, (e) => console.error(e));

    // --- UI ---
    const select = document.getElementById('region-select');
    for(let r in REGIONS) {
        const o = document.createElement('option');
        o.value = r; o.innerText = r; select.appendChild(o);
    }
    select.addEventListener('change', (e) => { 
        currentActiveRegion = e.target.value;
        // Tint solid brain
        solidMeshes.forEach(m => {
            let active = currentActiveRegion && REGIONS[currentActiveRegion].some(k => m.userData.originalName.includes(k));
            m.material = active ? MAT_SOLID_ACTIVE : MAT_SOLID;
        });
    });

    controls.addEventListener('start', () => controls.autoRotate = false);
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        updateSimulation();
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>