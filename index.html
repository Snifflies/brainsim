<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Brain Atlas - Debug Mode</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: monospace; }
        canvas { display: block; width: 100%; height: 100%; }

        #info-panel {
            position: fixed; top: 0; left: 0; width: 100%;
            padding: 20px; color: #00ff88; pointer-events: none;
            z-index: 100; text-align: center;
        }
        
        #ui-container {
            position: fixed; bottom: 30px; left: 0; width: 100%;
            display: flex; justify-content: center; pointer-events: auto; z-index: 10;
        }
        select {
            padding: 12px; background: #222; color: white;
            border: 1px solid #555; border-radius: 6px; font-size: 16px;
        }
        
        /* SPINNER */
        #loader {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 50px; height: 50px; border: 5px solid #333;
            border-top: 5px solid #00ff88; border-radius: 50%;
            animation: spin 1s infinite linear; z-index: 999;
        }
        @keyframes spin { 100% { transform: translate(-50%, -50%) rotate(360deg); } }
    </style>
</head>
<body>

<div id="loader"></div>
<div id="info-panel">INITIALIZING...</div>

<div id="ui-container">
    <select id="region-select"><option value="">Whole Brain</option></select>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

    const debugText = document.getElementById('info-panel');
    const loaderSpinner = document.getElementById('loader');

    // --- SCENE ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 30);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.minDistance = 5;
    controls.maxDistance = 100;

    // --- LIGHTING ---
    const ambient = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(10, 10, 10);
    scene.add(dirLight);

    // --- HELPERS ---
    // This RED BOX will show us where the brain SHOULD be.
    // If you see the box but no brain, the brain scale is wrong.
    const boxHelper = new THREE.BoxHelper(new THREE.Mesh(), 0xff0000);
    scene.add(boxHelper);

    // --- NEURON CLASS ---
    class NeuronManager {
        constructor(scene, count) {
            this.count = count;
            this.points = null;
            this.v = new Float32Array(count);
            this.u = new Float32Array(count);
            for(let i=0; i<count; i++) { 
                this.v[i] = -65 + Math.random()*20; 
                this.u[i] = 0.2 * this.v[i];
            }
        }

        init(frontalMeshes, parentObject) {
            debugText.innerText = `Placing ${this.count} neurons...`;
            
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(this.count * 3);
            const colors = new Float32Array(this.count * 3);
            
            const tempPos = new THREE.Vector3();
            const tempNormal = new THREE.Vector3();
            let created = 0;
            let meshIndex = 0;

            while(created < this.count) {
                const mesh = frontalMeshes[meshIndex % frontalMeshes.length];
                meshIndex++;
                const sampler = new MeshSurfaceSampler(mesh).build();
                
                for(let k=0; k<15 && created < this.count; k++) {
                    sampler.sample(tempPos, tempNormal);
                    
                    // Offset 
                    tempPos.addScaledVector(tempNormal, 0.005);

                    // IMPORTANT: Transform point to match mesh's local space within the brain group
                    tempPos.applyMatrix4(mesh.matrix);

                    positions[created*3] = tempPos.x;
                    positions[created*3+1] = tempPos.y;
                    positions[created*3+2] = tempPos.z;
                    
                    colors[created*3] = 0.0; colors[created*3+1] = 0.0; colors[created*3+2] = 0.4;
                    created++;
                }
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.003, // Tiny because model is tiny
                vertexColors: true, transparent: true, opacity: 1,
                blending: THREE.AdditiveBlending, depthWrite: false
            });

            this.points = new THREE.Points(geometry, material);
            parentObject.add(this.points); // Attach to Brain Group
        }

        update() {
            if (!this.points) return;
            const colors = this.points.geometry.attributes.color.array;
            const dt = 0.5;
            
            for (let i = 0; i < this.count; i++) {
                const input = (Math.random() > 0.99) ? 20 : 0; 
                let v = this.v[i], u = this.u[i];
                
                v += (0.04 * v * v + 5 * v + 140 - u + input) * dt;
                u += (0.02 * (0.2 * v - u)) * dt;

                if (v >= 30.0) { 
                    v = -65.0; u += 8.0;
                    colors[i*3] = 0.5; colors[i*3+1] = 1.0; colors[i*3+2] = 1.0;
                } else { 
                    colors[i*3] *= 0.9; colors[i*3+1] *= 0.9; colors[i*3+2] = Math.max(0.2, colors[i*3+2]*0.95);
                }
                this.v[i] = v; this.u[i] = u;
            }
            this.points.geometry.attributes.color.needsUpdate = true;
        }
    }

    // --- MATERIALS & CONFIG ---
    const MAT_BASE = new THREE.MeshLambertMaterial({ color: 0xdddddd });
    const MAT_ACTIVE = new THREE.MeshLambertMaterial({ color: 0xff0055, emissive: 0x440022, emissiveIntensity: 0.5 });
    const MAT_GHOST = new THREE.MeshLambertMaterial({ color: 0x151515 }); // Dark Opaque

    const REGIONS = {
        "Frontal Lobe": ["frontal", "precentral", "rectus", "orbital", "cingulate"],
        // ... (Keep list short for brevity, add others as needed)
    };
    
    const neuronSim = new NeuronManager(scene, 5000);
    const rootGroup = new THREE.Group();
    scene.add(rootGroup);
    
    let allParts = [];
    let frontalParts = [];

    // --- LOAD ---
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
    const loader = new GLTFLoader();
    loader.setDRACOLoader(dracoLoader);

    debugText.innerText = "DOWNLOADING MODEL...";

    loader.load('./rotten_brain.glb?v=' + Math.random(), (gltf) => {
        
        const brain = gltf.scene;
        
        // 1. MATERIAL & PART SETUP
        brain.traverse((child) => {
            if (child.isMesh) {
                // Reset transforms to prevent weird offsets
                // child.position.set(0,0,0); 
                // ^ DON'T DO THIS for segmented brains, they need their offsets!
                
                if(child.material) child.material.dispose();
                child.material = MAT_BASE;
                child.userData.originalName = (child.name || "").toLowerCase();
                allParts.push(child);
                
                if (child.userData.originalName.includes("frontal") || 
                    child.userData.originalName.includes("precentral")) {
                    frontalParts.push(child);
                }
            }
        });

        // 2. ADD TO GROUP
        rootGroup.add(brain);

        // 3. CENTER THE GROUP
        const box = new THREE.Box3().setFromObject(rootGroup);
        const size = new THREE.Vector3(); box.getSize(size);
        const center = new THREE.Vector3(); box.getCenter(center);
        
        // Debug info
        console.log("Model Size:", size);
        console.log("Model Center:", center);
        
        // Shift brain to center
        brain.position.x = -center.x;
        brain.position.y = -center.y;
        brain.position.z = -center.z;

        // 4. SCALE THE GROUP
        const maxDim = Math.max(size.x, size.y, size.z);
        if (maxDim > 0) {
            const scale = 10.0 / maxDim;
            rootGroup.scale.setScalar(scale);
            debugText.innerText = `Scaled x${scale.toFixed(2)}`;
        }

        // 5. UPDATE BOX HELPER (So we can see it)
        boxHelper.setFromObject(rootGroup);
        
        // 6. INIT NEURONS (Attached to 'brain' so they move with it)
        if(frontalParts.length > 0) {
            neuronSim.init(frontalParts, brain);
        }

        loaderSpinner.style.display = 'none';
        setTimeout(() => debugText.style.display = 'none', 2000);

    }, undefined, (err) => {
        debugText.innerText = "ERROR: " + err.message;
        debugText.style.color = "red";
    });

    // --- UI ---
    // (Simple toggle logic)
    const selectEl = document.getElementById('region-select');
    selectEl.addEventListener('change', (e) => {
        // Simple placeholder logic
        allParts.forEach(p => p.material = MAT_BASE);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        neuronSim.update();
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>
